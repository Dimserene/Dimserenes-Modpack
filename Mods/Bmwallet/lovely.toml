[manifest]
version = "1.0.3e"
dump_lua = true
priority = 0

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''G.SPLASH_BACK = Sprite(-30, -6, G.ROOM.T.w+60, G.ROOM.T.h+12, G.ASSET_ATLAS["ui_1"], {x = 2, y = 0})'''
position = "before"
payload = '''
    self.bm_wallet = CardArea(G.jokers.T.x, G.jokers.T.y, 4.9*G.CARD_W, 0.95*G.CARD_H, {
            card_limit = 5,
            type = "bm_wallet",
            highlight_limit = 1
    })
    self.bm_wallet.card_w=self.bm_wallet.card_w
'''
match_indent = true
overwrite = false

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''if self.highlighted and self.area and self.area.config.type ~= 'shop' then'''
position = "at"
payload = '''
if self.highlighted and self.area and self.area.config.type ~= 'shop' and self.area.config.type ~= 'bm_wallet' then
'''
match_indent = true
overwrite = false

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''if self.children.use_button then self.children.use_button:remove(); self.children.use_button = nil end'''
position = "before"
payload = '''
if self.children.restore_button then self.children.restore_button:remove(); self.children.restore_button = nil end
'''
match_indent = true
overwrite = false

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''if not self.states.focus.is and self.children.focused_ui then'''
position = "before"
payload = '''
if self.states.drag.is and self:can_mobile_card() then
    local prev_area = self:get_prev_area()
    local possible_areas = {prev_area, G.bm_wallet}
    possible_areas = remove_nils(possible_areas)
    local card_x = self.VT.x+self.VT.w/2
    local card_y = self.VT.y+self.VT.h/2
    for i, v in ipairs(possible_areas) do
        if v.T.x < card_x and card_x < v.T.x + v.T.w and v.T.y < card_y and card_y < v.T.y + v.T.h then
            if (self.area == nil or self.area ~= v) and (v == G.hand or v.config.card_limit > #v.cards) then
                if (G.GAME.exchange == nil and v == G.bm_wallet) or (G.GAME.exchange == true and v == G.jokers) then
                    return
                end
                if v == G.hand and not (G.hand and G.hand.cards[1]) then
                    return
                end
                if self.area then
                    self.area:remove_card(self)
                end
                v:emplace(self)
            end
        end          
    end
end
'''
match_indent = true
overwrite = false

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''if (not v.parent and v ~= self.CONTROLLER.dragging.target and v ~= self.CONTROLLER.focused.target) then'''
position = "before"
payload = '''
]]
        for k, v in pairs(self.I.CARDAREA) do
            if not v.parent then 
                love.graphics.push()
                v:translate_container()
                v:draw()
                love.graphics.pop()
            end
        end
    else
    if (not self.OVERLAY_MENU) or (not self.F_HIDE_BG) then 
        timer_checkpoint('primatives', 'draw')
        for k, v in pairs(self.I.UIBOX) do
            if not v.attention_text and not v.parent and v ~= self.OVERLAY_MENU and v ~= self.screenwipe and v ~= self.OVERLAY_TUTORIAL and v ~= self.debug_tools and v ~= self.online_leaderboard and v ~= self.achievement_notification then 
                love.graphics.push()
                v:translate_container()
                v:draw()
                love.graphics.pop()
            end
        end
            timer_checkpoint('uiboxes', 'draw')
        for k, v in pairs(self.I.CARDAREA) do
            if not v.parent then
            if G.GAME.exchange == nil then
                if v ~= G.bm_wallet then
                    love.graphics.push()
                    v:translate_container()
                    v:draw()
                    love.graphics.pop()
                end
            else
                if v ~= G.jokers then
                    love.graphics.push()
                    v:translate_container()
                    v:draw()
                    love.graphics.pop()
                end
            end
            end
        end

        for k, v in pairs(self.I.CARD) do
'''
match_indent = true
overwrite = false

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''if G.debug_splash_size_toggle then'''
position = "after"
payload = '''
--[[
'''
match_indent = true
overwrite = false

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''self.HUD = UIBox{'''
position = "before"
payload = '''

local t = create_UIBox_HUD()
local raw_contents_buttons = t.nodes[1].nodes[1].nodes[5].nodes[1].nodes
local raw_run_info = raw_contents_buttons[1].nodes[1]
local raw_options = raw_contents_buttons[1].nodes[2]
local raw_contents_buttons_in = raw_contents_buttons[1].nodes
raw_run_info.config.minh = 1.5
raw_options.config.minh = 1.1
raw_contents_buttons_in[#raw_contents_buttons_in + 1] = {n=G.UIT.R, config={align = "cm", minh = 0.8, minw = 1.5,padding = 0.05, r = 0.1, hover = true, colour = G.C.BLUE, button = "set_exchange", shadow = true}, nodes={
    {n=G.UIT.C, config={align = "cm", maxw = 1.4, focus_args = {button = 'start', orientation = 'bm'}, func = 'set_button_pip'}, nodes={
        {n=G.UIT.T, config={text = localize('b_switch'), scale = 0.4, colour = G.C.UI.TEXT_LIGHT, shadow = true}}
    }},
}}
'''
match_indent = true
overwrite = false

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''definition = create_UIBox_HUD(),'''
position = "at"
payload = '''
definition = t,
'''
match_indent = true
overwrite = false

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''perma_bonus = self.ability and self.ability.perma_bonus or 0,'''
position = "before"
payload = '''
f_level = self.ability and self.ability.f_level or 0,
f_chips = self.ability and self.ability.f_chips or 0,
f_mult = self.ability and self.ability.f_mult or 0,
f_x_mult = self.ability and self.ability.f_x_mult or 0,
'''
match_indent = true
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''local chips = card:get_chip_bonus()'''
position = "before"
payload = '''
local f_chips = card:get_f_chips()
if f_chips > 0 then
    ret.f_chips = f_chips
end

local f_mult = card:get_f_mult()
if f_mult > 0 then
    ret.f_mult = f_mult
end

local f_x_mult = card:get_f_x_mult()
if f_x_mult > 1 then
    ret.f_x_mult = f_x_mult
end
'''
match_indent = true
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''elseif eval_type == 'chips' then'''
position = "before"
payload = '''
elseif eval_type == 'f_chips' then
    sound = 'chips1'
    amt = amt
    colour = G.C.CHIPS
    text = localize{type='variable',key='a_chips',vars={amt}}
    delay = 0.6
elseif eval_type == 'f_mult' then
    sound = 'multhit1'--'other1'
    amt = amt
    text = localize{type='variable',key='a_mult',vars={amt}}
    colour = G.C.MULT
    config.type = 'fade'
    config.scale = 0.7
elseif eval_type == 'f_x_mult' then
    sound = 'multhit2'
    volume = 0.7
    amt = amt
    text = localize{type='variable',key='a_xmult',vars={amt}}
    colour = G.C.XMULT
    config.type = 'fade'
    config.scale = 0.7
'''
match_indent = true
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''--If x_mult added, do mult add event and mult the mult to the total'''
position = "after"
payload = '''
if effects[ii].f_chips then 
    if effects[ii].card then juice_card(effects[ii].card) end
    hand_chips = mod_chips(hand_chips + effects[ii].f_chips)
    update_hand_text({delay = 0}, {chips = hand_chips})
    card_eval_status_text(scoring_hand[i], 'f_chips', effects[ii].f_chips, percent)
end
if effects[ii].f_mult then 
    if effects[ii].card then juice_card(effects[ii].card) end
    mult = mod_mult(mult + effects[ii].f_mult)
    update_hand_text({delay = 0}, {mult = mult})
    card_eval_status_text(scoring_hand[i], 'f_mult', effects[ii].f_mult, percent)
end
if effects[ii].f_x_mult then 
    if effects[ii].card then juice_card(effects[ii].card) end
    mult = mod_mult(mult*effects[ii].f_x_mult)
    update_hand_text({delay = 0}, {mult = mult})
    card_eval_status_text(scoring_hand[i], 'f_x_mult', effects[ii].f_x_mult, percent)
end
'''
match_indent = true
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''--matches with any new changes of compatibility determined by the Joker'''
position = "after"
payload = '''

G.FUNCS.check_drag_target_active = function(e)
    if e.config.args.active_check(e.config.args.card) then
        if (not e.config.pulse_border) or not e.config.args.init then
            e.config.pulse_border = true
            e.config.colour = e.config.args.colour
            e.config.args.text_colour[4] = 1
            e.config.release_func = e.config.args.release_func
        end
    else
        if (e.config.pulse_border) or not e.config.args.init then 
            e.config.pulse_border = nil
            e.config.colour = adjust_alpha(G.C.L_BLACK, 0.9)
            e.config.args.text_colour[4] = 0.5
            e.config.release_func = nil
        end
    end
    e.config.args.init = true
end

G.FUNCS.can_buy_touch = function(_card)
    if _card.cost > (G.GAME.dollars - G.GAME.bankrupt_at) and (_card.cost > 0) then
        return false
    end
    return true
end

G.FUNCS.can_use_touch = function(_card)
    if not _card.ability.consumeable then
        return false
    end
    if (not _card:can_use_consumeable()) then
        return false
    end
    return true
end

G.FUNCS.can_buy_and_use_touch = function(_card)
    if not _card.ability.consumeable then
        return false
    end
    if (((_card.cost > G.GAME.dollars - G.GAME.bankrupt_at) and (_card.cost > 0)) or (not _card:can_use_consumeable())) then
        return false
    end
    return true
end

G.FUNCS.can_select_card_touch = function(_card)
    if _card.ability.set ~= 'Joker' or (_card.edition and _card.edition.negative) or #G.jokers.cards < G.jokers.config.card_limit then 
        return true
    end
    return false
end

G.FUNCS.can_sell_card_touch = function(_card)
    if _card:can_sell_card() then 
        return true
    else
        return false
    end
end

'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/misc_functions.lua"
pattern = '''function boot_timer(_label, _next, progress)'''
position = "before"
payload = '''
function create_drag_target_from_card(_card)
    if _card and G.STAGE == G.STAGES.RUN then
        G.DRAG_TARGETS = G.DRAG_TARGETS or {
            S_buy = Moveable{T={x = G.jokers.T.x, y = G.jokers.T.y - 0.1, w = G.consumeables.T.x + G.consumeables.T.w - G.jokers.T.x, h = G.jokers.T.h+0.6}},
            S_buy_and_use = Moveable{T={x = G.deck.T.x + 0.2, y = G.deck.T.y - 5.1, w = G.deck.T.w-0.1, h = 4.5}},
            C_use = Moveable{T={x = G.deck.T.x + 0.2, y = G.deck.T.y - 5.1, w = G.deck.T.w-0.1, h =4.5}},
            W_hide = Moveable{T={x = G.deck.T.x + 0.2, y = G.deck.T.y - 5.1, w = G.deck.T.w-0.1, h = 4.5}},
            W_restore = Moveable{T={x = G.deck.T.x + 0.2, y = G.deck.T.y - 5.1, w = G.deck.T.w-0.1, h = 4.5}},
        }

        if _card.area and (_card.area == G.shop_jokers or _card.area == G.shop_vouchers or _card.area == G.shop_booster) then 
            local buy_loc = copy_table(localize((_card.area == G.shop_vouchers and 'ml_redeem_target') or (_card.area == G.shop_booster and 'ml_open_target') or 'ml_buy_target'))
            buy_loc[#buy_loc + 1] = '$'.._card.cost
            drag_target({ cover = G.DRAG_TARGETS.S_buy, colour = adjust_alpha(G.C.GREEN, 0.9), text = buy_loc,
                card = _card,
                active_check = (function(other)
                    return G.FUNCS.can_buy_touch(other)
                end),
                release_func = (function(other)
                    if other.area == G.shop_jokers and G.FUNCS.can_buy_touch(other) then 
                        if G.OVERLAY_TUTORIAL and G.OVERLAY_TUTORIAL.button_listen == 'buy_from_shop' then
                          G.FUNCS.tut_next()
                        end
                        G.FUNCS.buy_from_shop({config = {
                            ref_table = other,
                            id = 'buy'
                        }})
                        return
                    elseif other.area == G.shop_vouchers and G.FUNCS.can_buy_touch(other) then
                        G.FUNCS.use_card({config={ref_table = other}})
                    elseif other.area == G.shop_booster and G.FUNCS.can_buy_touch(other) then
                        G.FUNCS.use_card({config={ref_table = other}})
                    end
                end)
            })
            if G.FUNCS.can_buy_and_use_touch(_card) then
                local buy_use_loc = copy_table(localize('ml_buy_and_use_target'))
                buy_use_loc[#buy_use_loc + 1] = '$'.._card.cost
                drag_target({ cover = G.DRAG_TARGETS.S_buy_and_use, colour = adjust_alpha(G.C.ORANGE, 0.9),text=buy_use_loc,
                    card = _card,
                    active_check = (function(other)
                        return G.FUNCS.can_buy_and_use_touch(other)
                    end),  
                    release_func = (function(other)
                        if G.FUNCS.can_buy_and_use_touch(other) then 
                            G.FUNCS.buy_from_shop({config = {
                                ref_table = other,
                                id = 'buy_and_use'
                            }})
                            return
                        end
                    end)
                })
            end
        end

        if _card.area and (_card.area == G.jokers or _card.area == G.consumeables) then 
            if _card.area == G.jokers then
                drag_target({ cover = G.DRAG_TARGETS.W_hide, colour = adjust_alpha(G.C.BLUE, 0.9),text={localize('b_hide')},
                    card = _card,
                    active_check = (function(other)
                        return G.FUNCS.can_hide_card_touch(other)
                    end),  
                    release_func = (function(other)
                        if G.FUNCS.can_hide_card_touch(other) then 
                            G.FUNCS.hide_card({config = {
                                ref_table = other,
                                id = 'hide'
                            }})
                            return
                        end
                    end)
                })
            end
            if _card.area == G.consumeables then
                drag_target({ cover = G.DRAG_TARGETS.C_use, colour = adjust_alpha(G.C.RED, 0.9),text={localize('b_use')},
                    card = _card,
                    active_check = (function(other)
                        return G.FUNCS.can_use_touch(other)
                    end),  
                    release_func = (function(other)
                        if G.FUNCS.can_use_touch(other) then 
                            G.FUNCS.use_card({config={ref_table = other}})
                            if G.OVERLAY_TUTORIAL and G.OVERLAY_TUTORIAL.button_listen == 'use_card' then
                                G.FUNCS.tut_next()
                            end
                            return
                        end
                    end)
                })
            end
        end

        if _card.area and (_card.area == G.bm_wallet) then
            drag_target({ cover = G.DRAG_TARGETS.W_restore, colour = adjust_alpha(G.C.BLUE, 0.9),text={localize('b_restore')},
                card = _card,
                active_check = (function(other)
                    return G.FUNCS.can_restore_card_touch(other)
                end),
                release_func = (function(other)
                    if G.FUNCS.can_restore_card_touch(other) then
                        G.FUNCS.restore_card({config = {
                            ref_table = other,
                            id = 'restore'
                        }})
                        return
                    end
                end)
            })
            if _card.ability.set == 'Joker' then
                if G.FUNCS.can_recycle_card_touch(_card) then
                    recycle_loc = {localize('b_recycle')}
                    recycle_loc[#recycle_loc + 1] = '$'..2
                    W_recycle = Moveable{T={x = G.jokers.T.x+4, y = G.jokers.T.y+4.3, w = G.jokers.T.w*0.37, h = G.jokers.T.h}}
                    drag_target({ cover = W_recycle, colour = adjust_alpha(G.C.MULT, 0.9),text=recycle_loc,
                        card = _card,
                        active_check = (function(other)
                            return G.FUNCS.can_recycle_card_touch(other)
                        end),
                        release_func = (function(other)
                            if G.FUNCS.can_recycle_card_touch(other) then
                                G.FUNCS.recycle_card({config = {
                                    ref_table = other,
                                    id = 'recycle'
                                }})
                                return
                            end
                        end)
                    })
                end
                if G.FUNCS.can_maintenance_card_touch(_card) then
                    maintenance_loc = {localize('b_maintenance')}
                    maintenance_loc[#maintenance_loc + 1] = '$'..3*(G.GAME.perishable_rounds - _card.ability.perish_tally)
                    W_maintenance = Moveable{T={x = G.jokers.T.x+7.9, y = G.jokers.T.y+4.3, w = G.jokers.T.w*0.37, h = G.jokers.T.h}}
                    drag_target({ cover = W_maintenance, colour = adjust_alpha(G.C.SECONDARY_SET.Tarot, 0.9),text=maintenance_loc,
                        card = _card,
                        active_check = (function(other)
                            return G.FUNCS.can_maintenance_card_touch(other)
                        end),
                        release_func = (function(other)
                            if G.FUNCS.can_maintenance_card_touch(other) then
                                G.FUNCS.maintenance_card({config = {
                                    ref_table = other,
                                    id = 'maintenance'
                                }})
                                return
                            end
                        end)
                    })
                end
                if G.FUNCS.can_package_card_touch(_card) then
                    package_loc = {localize('b_package')}
                    package_loc[#package_loc + 1] = '$'..3
                    package_loc[#package_loc + 1] = localize('b_package_2')..(G.GAME.used_times_consumeable_type or 0)..'/'..2
                    W_package = Moveable{T={x = G.shop_booster.T.x, y = G.shop_booster.T.y, w = G.shop_booster.T.w, h = G.shop_booster.T.h}}
                    drag_target({ cover = W_package, colour = adjust_alpha(G.C.SECONDARY_SET.Planet, 0.9),text=package_loc,
                        card = _card,
                        active_check = (function(other)
                            return G.FUNCS.can_package_card_touch(other)
                        end),
                        release_func = (function(other)
                            if G.FUNCS.can_package_card_touch(other) then
                                G.FUNCS.package_card({config = {
                                    ref_table = other,
                                    id = 'package'
                                }})
                                return
                            end
                        end)
                    })
                end
                if G.FUNCS.can_printing_card_touch(_card) then
                    local printing_cost = _card:get_printing_cost()
                    printing_loc = {localize('b_printing')}
                    printing_loc[#printing_loc + 1] = '$'..printing_cost
                    W_printing = Moveable{T={x = G.shop_vouchers.T.x, y = G.shop_vouchers.T.y, w = G.shop_vouchers.T.w, h = G.shop_vouchers.T.h}}
                    drag_target({ cover = W_printing, colour = adjust_alpha(G.C.SECONDARY_SET.Spectral, 0.9),text=printing_loc,
                        card = _card,
                        active_check = (function(other)
                            return G.FUNCS.can_printing_card_touch(other)
                        end),
                        release_func = (function(other)
                            if G.FUNCS.can_printing_card_touch(other) then
                                G.FUNCS.printing_card({config = {
                                    ref_table = other,
                                    id = 'printing'
                                }})
                                return
                            end
                        end)
                    })
                end
                if G.FUNCS.can_forge_card_touch(_card) and G.GAME.bmjokers then
                    forge_loc = {localize('b_forge_practice')}
                    forge_loc[#forge_loc + 1] = '$'..400
                    J_forge = Moveable{T={x = G.consumeables.T.x, y = G.consumeables.T.y, w = G.consumeables.T.w, h = G.consumeables.T.h}}
                    drag_target({ cover = J_forge, colour = adjust_alpha(G.C.SECONDARY_SET.Enhanced, 0.9),text=forge_loc,
                        card = _card,
                        active_check = (function(other)
                            return G.FUNCS.can_forge_card_touch(other)
                        end),
                        release_func = (function(other)
                            if G.FUNCS.can_forge_card_touch(other) then
                                G.FUNCS.forge_card({config = {
                                    ref_table = other,
                                    id = 'forge'
                                }})
                                return
                            end
                        end)
                    })
                end
            end
            if _card.ability.consumeable then
                if G.FUNCS.can_package_card_touch(_card) then
                    package_loc = {localize('b_package')}
                    package_loc[#package_loc + 1] = '$'..3
                    package_loc[#package_loc + 1] = localize('b_package_2')..(G.GAME.used_times_consumeable_type or 0)..'/'..2
                    W_package = Moveable{T={x = G.shop_booster.T.x, y = G.shop_booster.T.y, w = G.shop_booster.T.w, h = G.shop_booster.T.h}}
                    drag_target({ cover = W_package, colour = adjust_alpha(G.C.SECONDARY_SET.Planet, 0.9),text=package_loc,
                        card = _card,
                        active_check = (function(other)
                            return G.FUNCS.can_package_card_touch(other)
                        end),
                        release_func = (function(other)
                            if G.FUNCS.can_package_card_touch(other) then
                                G.FUNCS.package_card({config = {
                                    ref_table = other,
                                    id = 'package'
                                }})
                                return
                            end
                        end)
                    })
                end
            end
            if _card.ability.set == 'Default' or _card.ability.set == 'Enhanced' then
                if G.FUNCS.can_printing_card_touch(_card) then
                    local printing_cost = _card:get_printing_cost()
                    printing_loc = {localize('b_printing')}
                    printing_loc[#printing_loc + 1] = '$'..printing_cost
                    W_printing = Moveable{T={x = G.shop_vouchers.T.x, y = G.shop_vouchers.T.y, w = G.shop_vouchers.T.w, h = G.shop_vouchers.T.h}}
                    drag_target({ cover = W_printing, colour = adjust_alpha(G.C.SECONDARY_SET.Spectral, 0.9),text=printing_loc,
                        card = _card,
                        active_check = (function(other)
                            return G.FUNCS.can_printing_card_touch(other)
                        end),
                        release_func = (function(other)
                            if G.FUNCS.can_printing_card_touch(other) then
                                G.FUNCS.printing_card({config = {
                                    ref_table = other,
                                    id = 'printing'
                                }})
                                return
                            end
                        end)
                    })
                end
                if G.FUNCS.can_forge_card_touch(_card) then
                    forge_loc = {localize('b_forge')}
                    forge_loc[#forge_loc + 1] = '$'..(10 + (_card.ability.f_level or 0)*3)
                    forge_loc[#forge_loc + 1] = localize('b_forge_percentage')..string.format("%.0f", (G.GAME.probabilities.normal/(_card.ability.f_level/3 + 1)*100))..'%'
                    P_forge = Moveable{T={x = G.shop_booster.T.x, y = G.shop_booster.T.y, w = G.shop_booster.T.w, h = G.shop_booster.T.h}}
                    drag_target({ cover = P_forge, colour = adjust_alpha(G.C.SECONDARY_SET.Enhanced, 0.9),text=forge_loc,
                        card = _card,
                        active_check = (function(other)
                            return G.FUNCS.can_forge_card_touch(other)
                        end),
                        release_func = (function(other)
                            if G.FUNCS.can_forge_card_touch(other) then
                                G.FUNCS.forge_card({config = {
                                    ref_table = other,
                                    id = 'forge'
                                }})
                                return
                            end
                        end)
                    })
                end
                if G.FUNCS.can_seal_card_touch(_card) then
                    seal_loc = {localize('b_seal')}
                    seal_loc[#seal_loc + 1] = '$'..15
                    P_seal = Moveable{T={x = G.jokers.T.x+7.9, y = G.jokers.T.y+4.3, w = G.jokers.T.w*0.37, h = G.jokers.T.h}}
                    drag_target({ cover = P_seal, colour = adjust_alpha(G.C.SECONDARY_SET.Voucher, 0.9),text=seal_loc,
                        card = _card,
                        active_check = (function(other)
                            return G.FUNCS.can_seal_card_touch(other)
                        end),
                        release_func = (function(other)
                            if G.FUNCS.can_seal_card_touch(other) then
                                G.FUNCS.seal_card({config = {
                                    ref_table = other,
                                    id = 'seal'
                                }})
                                return
                            end
                        end)
                    })
                end
            end
        end
    end
end

'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = '''function create_toggle(args)'''
position = "before"
payload = '''
function drag_target(args)
    args = args or {}
    args.text = args.text or {'BUY'}
    args.colour = copy_table(args.colour or G.C.UI.TRANSPARENT_DARK)
    args.cover = args.cover or nil
    args.emboss = args.emboss or nil
    args.active_check = args.active_check or (function(other) return true end)
    args.release_func = args.release_func or (function(other) G.DEBUG_VALUE = 'WORKIN' end)
    args.text_colour = copy_table(G.C.WHITE)
    args.uibox_config = {
      align = args.align or 'tli',
      offset = args.offset or {x=0,y=0}, 
      major = args.cover or args.major or nil,
    }

    local drag_area_width =(args.T and args.T.w or args.cover and args.cover.T.w or 0.001) + (args.cover_padding or 0)

    local text_rows = {}
    for k, v in ipairs(args.text) do
        text_rows[#text_rows+1] = {n=G.UIT.R, config={align = "cm", padding = 0.05, maxw = drag_area_width-0.1}, nodes={{n=G.UIT.O, config={object = DynaText({scale = args.scale, string = v, maxw = args.maxw or (drag_area_width-0.1), colours = {args.text_colour},float = true, shadow = true, silent = not args.noisy, 0.7, pop_in = 0, pop_in_rate = 6, rotate = args.rotate or nil})}}}}
    end

    args.DT = UIBox{
        T = {0,0,0,0},
        definition = 
          {n=G.UIT.ROOT, config = {align = 'cm',  args = args, can_collide = true, hover = true, release_func = args.release_func, func = 'check_drag_target_active', minw = drag_area_width, minh = (args.cover and args.cover.T.h or 0.001) + (args.cover_padding or 0), padding = 0.03, r = 0.1, emboss = args.emboss, colour = G.C.CLEAR}, nodes=text_rows}, 
        config = args.uibox_config
    }
    args.DT.attention_text = true

    if G.OVERLAY_TUTORIAL and G.OVERLAY_TUTORIAL.highlights then 
        G.OVERLAY_TUTORIAL.highlights[#G.OVERLAY_TUTORIAL.highlights+1] = args.DT
    end

    G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0,blockable = false,blocking = false,func = function()
        if not G.CONTROLLER.dragging.target and args.DT then 
            if G.OVERLAY_TUTORIAL and G.OVERLAY_TUTORIAL.highlights then
                for k, v in ipairs(G.OVERLAY_TUTORIAL.highlights) do
                    if args.DT == v then 
                        table.remove(G.OVERLAY_TUTORIAL.highlights, k)
                        break
                    end
                end
            end
            args.DT:remove()
        return true end 
    end}))
end

'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "engine/controller.lua"
pattern = '''--if not, was the Cursor dragging some other thing?'''
position = "after"
payload = '''
--[[
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "engine/controller.lua"
pattern = '''--Cursor is currently hovering over something'''
position = "before"
payload = '''
]]
                end
            elseif self.dragging.prev_target then 
                local releasable = nil
                for _, v in ipairs(self.collision_list) do
                    if v.states.hover.can and (not v.states.drag.is) and (v ~= self.dragging.prev_target) then
                        releasable = v
                        break 
                    end
                end
                if releasable and releasable.states.release_on.can then 
                    self.released_on.target = releasable
                    self.released_on.handled = false
                end
            end
        end
        self.cursor_up.handled = true
    end

'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "engine/controller.lua"
pattern = '''--The object being dragged'''
position = "before"
payload = '''
    if not self.dragging.handled and self.cursor_down.distance and (self.cursor_down.distance > 0.2) then
        create_drag_target_from_card(self.dragging.target)
        self.dragging.handled = true
    end

'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "engine/controller.lua"
pattern = '''--The object released on'''
position = "after"
payload = '''
--[[
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "engine/controller.lua"
pattern = '''--The object being hovered over'''
position = "before"
payload = '''
]]
    if not self.released_on.handled and self.dragging.prev_target then
        self.released_on.target:release(self.dragging.prev_target)
        self.released_on.handled = true
    end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "engine/controller.lua"
pattern = '''if self.hovering.target and self.hovering.target == self.dragging.target and not self.HID.touch then'''
position = "before"
payload = '''
    if self.is_cursor_down then 
        self.cursor_down.distance = math.max(Vector_Dist(self.cursor_down.T, self.cursor_hover.T), self.cursor_down.distance or 0)
    end
    if not self.is_cursor_down then
        if self.cursor_down.target then
            self.cursor_down.duration = nil
        end
    end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "engine/controller.lua"
pattern = '''if not self.cursor_down.handled then'''
position = "after"
payload = '''
    self.cursor_down.distance = 0
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "engine/ui.lua"
pattern = '''if self.parent then self.parent:release(other) end'''
position = "before"
payload = '''
    if self.config.release_func then 
        self.config.release_func(other)
    end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "engine/ui.lua"
pattern = '''--Draw the outline for highlighted buttons'''
position = "before"
payload = '''
    if self.config.pulse_border then
        self.border_pulse_timer = self.border_pulse_timer or G.TIMERS.REAL
        local lw = 2*math.max(0, 0.5*math.cos(6*(G.TIMERS.REAL - self.border_pulse_timer)) + 0.5)
        prep_draw(self, 1)
        love.graphics.scale((1)/(G.TILESIZE))
        love.graphics.setLineWidth(lw + 1)
        love.graphics.setColor(adjust_alpha(G.C.BLACK, 0.2*lw, true))
        self:draw_pixellated_rect('fill', parallax_dist)
        love.graphics.setColor(self.config.colour[4] > 0 and mix_colours(G.C.WHITE, self.config.colour, 0.8) or G.C.WHITE)
        self:draw_pixellated_rect('line', parallax_dist)
        love.graphics.pop()
    end
    
'''
match_indent = false
overwrite = false